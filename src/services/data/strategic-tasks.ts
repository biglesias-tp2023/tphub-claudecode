/**
 * Strategic Tasks (linked to objectives) data operations
 */

import {
  supabase,
  handleQueryError,
  isDevMode,
  mockStrategicTasks,
  addMockStrategicTask,
  updateMockStrategicTask,
  deleteMockStrategicTask,
} from './shared';
import { mapDbProfileToProfile } from './mappers';
import { fetchStrategicObjectives } from './strategic-objectives';
import type {
  StrategicObjective,
  StrategicTask,
  StrategicTaskInput,
  StrategicTaskWithDetails,
  Profile,
  ObjectiveCategory,
  ObjectiveResponsible,
  DbStrategicTask,
  DbProfile,
} from '@/types';

function mapDbStrategicTask(db: DbStrategicTask): StrategicTask {
  return {
    id: db.id,
    objectiveId: db.objective_id,
    restaurantId: db.restaurant_id,
    title: db.title,
    description: db.description,
    category: db.category as ObjectiveCategory,
    responsible: db.responsible as ObjectiveResponsible,
    assigneeId: db.assignee_id,
    clientName: db.client_name,
    deadline: db.deadline,
    isCompleted: db.is_completed,
    completedAt: db.completed_at,
    isAutoGenerated: db.is_auto_generated,
    templateKey: db.template_key,
    displayOrder: db.display_order,
    createdBy: db.created_by,
    updatedBy: db.updated_by,
    createdAt: db.created_at,
    updatedAt: db.updated_at,
  };
}

interface FetchStrategicTasksParams {
  restaurantIds?: string[];
  objectiveIds?: string[];
  isCompleted?: boolean;
  startDate?: string;
  endDate?: string;
}

/**
 * Fetch strategic tasks with optional filtering
 */
export async function fetchStrategicTasks(
  params: FetchStrategicTasksParams = {}
): Promise<StrategicTask[]> {
  // Return mock data in dev mode
  if (isDevMode) {
    return mockStrategicTasks.filter((task) => {
      if (params.restaurantIds?.length && !params.restaurantIds.includes(task.restaurantId)) {
        return false;
      }
      if (params.objectiveIds?.length && !params.objectiveIds.includes(task.objectiveId)) {
        return false;
      }
      if (params.isCompleted !== undefined && task.isCompleted !== params.isCompleted) {
        return false;
      }
      if (params.startDate && task.deadline && task.deadline < params.startDate) {
        return false;
      }
      if (params.endDate && task.deadline && task.deadline > params.endDate) {
        return false;
      }
      return true;
    });
  }

  let query = supabase
    .from('strategic_tasks')
    .select('*')
    .order('deadline', { ascending: true, nullsFirst: false })
    .order('display_order', { ascending: true });

  if (params.restaurantIds && params.restaurantIds.length > 0) {
    query = query.in('restaurant_id', params.restaurantIds);
  }
  if (params.objectiveIds && params.objectiveIds.length > 0) {
    query = query.in('objective_id', params.objectiveIds);
  }
  if (params.isCompleted !== undefined) {
    query = query.eq('is_completed', params.isCompleted);
  }
  if (params.startDate) {
    query = query.gte('deadline', params.startDate);
  }
  if (params.endDate) {
    query = query.lte('deadline', params.endDate);
  }

  const { data, error } = await query;

  if (error) handleQueryError(error, 'No se pudieron cargar las tareas estratégicas');
  return (data as DbStrategicTask[]).map(mapDbStrategicTask);
}

/**
 * Fetch strategic tasks with joined details (objective title, assignee name)
 */
export async function fetchStrategicTasksWithDetails(
  params: FetchStrategicTasksParams = {}
): Promise<StrategicTaskWithDetails[]> {
  // For now, fetch tasks and enrich with additional queries
  const tasks = await fetchStrategicTasks(params);

  if (tasks.length === 0) return [];

  // Get unique assignee IDs
  const assigneeIds = [...new Set(tasks.filter((t) => t.assigneeId).map((t) => t.assigneeId!))];

  // Fetch objectives (map restaurantIds to addressIds for CRP Portal model)
  const objectives = await fetchStrategicObjectives({ addressIds: params.restaurantIds });
  const objectiveMap = new Map(objectives.map((o) => [o.id, o]));

  // Fetch profiles if needed
  let profileMap = new Map<string, Profile>();
  if (assigneeIds.length > 0 && !isDevMode) {
    const { data: profiles } = await supabase
      .from('profiles')
      .select('*')
      .in('id', assigneeIds);
    if (profiles) {
      profileMap = new Map((profiles as DbProfile[]).map((p) => [p.id, mapDbProfileToProfile(p)]));
    }
  }

  // Enrich tasks
  return tasks.map((task) => {
    const objective = objectiveMap.get(task.objectiveId);
    const assignee = task.assigneeId ? profileMap.get(task.assigneeId) : undefined;

    return {
      ...task,
      objectiveTitle: objective?.title,
      assigneeName: assignee?.fullName || undefined,
      assigneeAvatarUrl: assignee?.avatarUrl,
    };
  });
}

/**
 * Create a strategic task
 */
export async function createStrategicTask(
  input: StrategicTaskInput
): Promise<StrategicTask> {
  // Mock mode
  if (isDevMode) {
    return addMockStrategicTask({
      objectiveId: input.objectiveId,
      restaurantId: input.restaurantId,
      title: input.title,
      description: input.description || null,
      category: input.category,
      responsible: input.responsible,
      assigneeId: input.assigneeId || null,
      clientName: input.clientName || null,
      deadline: input.deadline || null,
      isCompleted: false,
      completedAt: null,
      isAutoGenerated: input.isAutoGenerated ?? false,
      templateKey: input.templateKey || null,
      displayOrder: input.displayOrder || 0,
      createdBy: 'dev-user-001',
      updatedBy: 'dev-user-001',
    });
  }

  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id || null;

  const dbInput = {
    objective_id: input.objectiveId,
    restaurant_id: input.restaurantId,
    title: input.title,
    description: input.description || null,
    category: input.category,
    responsible: input.responsible,
    assignee_id: input.assigneeId || null,
    client_name: input.clientName || null,
    deadline: input.deadline || null,
    is_auto_generated: input.isAutoGenerated ?? false,
    template_key: input.templateKey || null,
    display_order: input.displayOrder || 0,
    created_by: userId,
    updated_by: userId,
  };

  const { data, error } = await supabase
    .from('strategic_tasks')
    .insert(dbInput)
    .select()
    .single();

  if (error) handleQueryError(error, 'Error al crear la tarea estratégica');
  return mapDbStrategicTask(data as DbStrategicTask);
}

/**
 * Generate tasks for an objective from templates
 */
export async function generateTasksForObjective(
  objective: StrategicObjective,
  companyName?: string
): Promise<StrategicTask[]> {
  // Import templates dynamically to avoid circular dependencies
  const { getTaskTemplatesForObjective } = await import('@/features/strategic/config/objectiveConfig');

  const templates = getTaskTemplatesForObjective(objective.objectiveTypeId);

  if (templates.length === 0) return [];

  const tasks: StrategicTask[] = [];

  for (let i = 0; i < templates.length; i++) {
    const template = templates[i];

    // Calculate deadline based on objective evaluation date
    let deadline: string | undefined;
    if (objective.evaluationDate) {
      const evalDate = new Date(objective.evaluationDate);
      evalDate.setDate(evalDate.getDate() + template.daysFromObjectiveDeadline);
      deadline = evalDate.toISOString();
    }

    const task = await createStrategicTask({
      objectiveId: objective.id,
      restaurantId: objective.addressId || '',  // Map addressId to restaurantId for task
      title: template.title,
      description: template.description,
      category: objective.category,
      responsible: template.responsible,
      clientName: template.responsible === 'cliente' ? companyName : undefined,
      deadline,
      isAutoGenerated: true,
      templateKey: template.key,
      displayOrder: i,
    });

    tasks.push(task);
  }

  return tasks;
}

/**
 * Update a strategic task
 */
export async function updateStrategicTask(
  id: string,
  updates: Partial<StrategicTaskInput> & { isCompleted?: boolean }
): Promise<StrategicTask> {
  // Mock mode
  if (isDevMode) {
    const task = updateMockStrategicTask(id, updates);
    if (!task) throw new Error('Task not found');
    return task;
  }

  const { data: { user } } = await supabase.auth.getUser();
  const userId = user?.id || null;

  const dbUpdates: Record<string, unknown> = { updated_by: userId };

  if (updates.title !== undefined) dbUpdates.title = updates.title;
  if (updates.description !== undefined) dbUpdates.description = updates.description;
  if (updates.responsible !== undefined) dbUpdates.responsible = updates.responsible;
  if (updates.assigneeId !== undefined) dbUpdates.assignee_id = updates.assigneeId;
  if (updates.clientName !== undefined) dbUpdates.client_name = updates.clientName;
  if (updates.deadline !== undefined) dbUpdates.deadline = updates.deadline;
  if (updates.displayOrder !== undefined) dbUpdates.display_order = updates.displayOrder;
  if (updates.isCompleted !== undefined) {
    dbUpdates.is_completed = updates.isCompleted;
    dbUpdates.completed_at = updates.isCompleted ? new Date().toISOString() : null;
  }

  const { data, error } = await supabase
    .from('strategic_tasks')
    .update(dbUpdates)
    .eq('id', id)
    .select()
    .single();

  if (error) handleQueryError(error, 'Error al actualizar la tarea estratégica');
  return mapDbStrategicTask(data as DbStrategicTask);
}

/**
 * Toggle strategic task completion
 */
export async function toggleStrategicTaskCompleted(id: string): Promise<StrategicTask> {
  // First fetch the current state
  if (isDevMode) {
    const task = mockStrategicTasks.find((t) => t.id === id);
    if (!task) throw new Error('Task not found');
    return updateStrategicTask(id, { isCompleted: !task.isCompleted });
  }

  const { data: current, error: fetchError } = await supabase
    .from('strategic_tasks')
    .select('is_completed')
    .eq('id', id)
    .single();

  if (fetchError) throw new Error(`Error fetching task: ${fetchError.message}`);

  return updateStrategicTask(id, { isCompleted: !current.is_completed });
}

/**
 * Delete a strategic task
 */
export async function deleteStrategicTask(id: string): Promise<void> {
  // Mock mode
  if (isDevMode) {
    deleteMockStrategicTask(id);
    return;
  }

  const { error } = await supabase
    .from('strategic_tasks')
    .delete()
    .eq('id', id);

  if (error) handleQueryError(error, 'Error al eliminar la tarea estratégica');
}

/**
 * Delete all tasks for an objective
 */
export async function deleteTasksForObjective(objectiveId: string): Promise<void> {
  if (isDevMode) {
    const indices = mockStrategicTasks
      .map((t, i) => (t.objectiveId === objectiveId ? i : -1))
      .filter((i) => i !== -1)
      .reverse();
    for (const i of indices) {
      mockStrategicTasks.splice(i, 1);
    }
    return;
  }

  const { error } = await supabase
    .from('strategic_tasks')
    .delete()
    .eq('objective_id', objectiveId);

  if (error) handleQueryError(error, 'Error al eliminar tareas del objetivo');
}
